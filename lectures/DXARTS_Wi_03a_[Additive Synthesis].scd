/* DXARTS 461 Digital Sound Synthesis: Class 3 - Additive Synthesis */



/*
Visualization

Let's start with having a look briefly at some of the ways we can visualize signals generated by the synthesis server. We've already seen in passing the use of Stethoscope to display an oscilloscope type GUI. This is easily done using the -scope method, which is what we've seen previously:

*/


// start server!
Server.default = s = Server.local.boot; // use this for SC-IDE

// simple example showing the -scope method
// this is a short cut for calling -play on the function, and Server-scope to open
// a scope window in which to view the output.
// (signal on left channel only!)
(
{SinOsc.ar(440.0, 0, -9.dbamp)}.scope;
)
// cmd-. to stop
// then, close scope window by hand


// if we want to be more explicit, we can invoke Stethoscope with its -new method:
(
var numChannels = 1;

{SinOsc.ar(440.0, 0, -9.dbamp)}.play;
Stethoscope.new(s, numChannels);
)
// cmd-. to stop
// then, close scope window by hand

/*

The Stethoscope is useful to view our resulting synthesis in real-time. Have a look at the help [Stethoscope] to review the various methods and their arguments. Don't worry if you don't quite understand all these now. But, do play with some of the examples.

Supercollider also includes another useful real-time display called FreqScope. This displays the frequency spectrum of a signal.

*/

// We invoke FreqScope with its -new method:
(
{SinOsc.ar(440.0, 0, -9.dbamp)}.play;
FreqScope.new;
)
// cmd-. to stop
// then, close scope window by hand


/*

FreqScope has different arguments from Stethoscope. Among other things, we don't need to provide a server for the -new method. Also note, FreqScope only views a single channel at a time. See the help for [FreqScope] for more details.

As you'd imagine, there is noting stopping us from using both Stethoscope and FreqScope together:

*/

(
var numChannels = 1;

{SinOsc.ar(440.0, 0, -9.dbamp)}.play;
Stethoscope.new(s, numChannels);
FreqScope.new;
)
// cmd-. to stop
// then, close scope window by hand


/*

Another useful method is -plot. The output of UGens enclosed in a function can be captured and displayed (outside of real-time) in this way. The server must be running.

*/

// a single single period of sine wave
(
var freq = 440.0;

{SinOsc.ar(freq)}.plot(freq.reciprocal) // -plot(freq.reciprocal) gives us a single period
)


// a number of harmonics (harmonic series)
(
var freq = 440.0, numHarmonics = 8;

{
	{arg i;
		SinOsc.ar((1 + i) * freq)
    }.dup(numHarmonics) // -dup returns an Array consisting of the results of numHarmonics
	                    // evaluations of this Function
}.plot(freq.reciprocal) // -plot(freq.reciprocal) gives us a single period of the fundamental
)



/*
Approaches to additive synthesis:

Additive synthesis is usually defined as the combination of multiple versions of a simpler signal to create a more complex one. There are three 'basic' ways to do this in SuperCollider, each with advantages and disadvantages. I'll define these as:

1) single sinusoid synthDef model
2) multiple sinusoid synthDef model
3) wavetable model

The 1st method gives the most flexibility and control over the individual partials that are added together to create a resulting timbre. (We'll be focusing on that here.) And, like Risset in Mutations, it is possible using this model to play with harmonic fusion and other perceptual features. In this approach, we will make a CtkSynthDef that will control a single sinusoidal partial. We will then create more complex sounds by calling multiple notes at the same time.

When you output two sounds to the same output bus, scsynth sums those outputs.

*/


// reopen the displays..
(
var numChannels = 1; // for the scope

// display!
Stethoscope.new(s, numChannels);
FreqScope.new;
)



// We'll use a SynthDef equivalent to the design found in D&J fig 4.11
//
// 1st we'll synthesise just a fundamental
// and then then 1st three harmonics
//
// We'll do all of this 'by hand' by calling individual notes
// The result is equivalent to fig 4.12 on pg 88 of D&J.
(
var note1, note2, note3, note4, score, synthDef;

synthDef = CtkSynthDef.new(\mySinOscSynth, {arg dur, amp, ris = 0.1, dec = 0.1, freq = 440.0;
	var env, envGen;

	env = Env.linen(ris, 1.0 - (ris + dec), dec); // env define within synthDef
	envGen = EnvGen.kr(env, timeScale: dur);
	amp = envGen * amp;

	Out.ar(0, Pan2.ar(
		// 'amp' is a value between 0 and 1.
		SinOsc.ar(freq, 0, amp)
		)
	)
}).send(s);

// start, dur, dur, amp, ris, dec freq
// fundamental only!
note1 = synthDef.note(starttime: 0.1, duration: 4.0).dur_(4.0).amp_(-9.dbamp).freq_(440.0);

// 1st three harmonics, 4 seconds later!
note2 = synthDef.note(starttime: 4.1, duration: 4.0).dur_(4.0).amp_(-18.dbamp).freq_(1 * 440.0);
note3 = synthDef.note(starttime: 4.1, duration: 4.0).dur_(4.0).amp_(-18.dbamp).freq_(2 * 440.0);
note4 = synthDef.note(starttime: 4.1, duration: 4.0).dur_(4.0).amp_(-18.dbamp).freq_(3 * 440.0);


// create a score
score = CtkScore.new;

// add fundamental to the score
score.add(note1);

// add 1st three harmonics to the score
score.add(note2);
score.add(note3);
score.add(note4);


// play the score
score.play;
)



/*

If we look at the additive synthesis diagram on Dodge, page 88, this 'summing' of signals that scsynth does for you is represented in the diagram with the '+' portion of the signal flow. We can output as many notes as we want at the same time to bus 0 and 1 (Left and Right) in the above example, and if their onset and attack envelope are similar, we will perceive then as a single complex sound rather then two different sounds.

The next example is somewhat complex in that we define a Function that will add notes (single sines) to a score to produce clarinet-like tones. This function will then be called every time we want to play a new 'clarinet' note. The Function, additiveFunc, makes life easier in that whenever we want to create a new 'clarinet' note, we don't have to individually specify each sine; additiveFunc does this for us.

*/


(
var score, synthDef;
var additiveFunc;
var partialGains = [0, -30, -6, -36, -9, -44, -18, -76, -24, -66, -36]; // gains for clarinet-like timbre

synthDef = CtkSynthDef.new(\mySinOscSynth, {arg dur, amp, ris = 0.1, dec = 0.1, freq = 440.0;
	var env, envGen;

	env = Env.linen(ris, 1.0 - (ris + dec), dec); // env define within synthDef
	envGen = EnvGen.kr(env, timeScale: dur);
	amp = envGen * amp;

	Out.ar(0, Pan2.ar(
		// 'amp' is a value between 0 and 1.
		SinOsc.ar(freq, 0, amp)
		)
	)
}).send(s);

// function to add individual notes to our score for additive synthesis
additiveFunc = {arg start, dur, amp, ris = 0.1, dec = 0.1, freq = 440.0, partialGains; // pass in values

	// iterate through the partialGains array to generate individual notes to add to the score
	partialGains.do({arg thisPartialGain, i;
		var thisPartialAmp;
		var thisPartialFreq;
		var thisPartialNote;

		thisPartialAmp = amp * (thisPartialGain.dbamp); // convert thisPartialGain to amp scale and
		                                                // then scale overall amplitude
		thisPartialFreq = freq * (i + 1); // multiply freq by index (harmonic series!)

		// create a note for each partial...
		thisPartialNote = synthDef.note(
			starttime: start, duration: dur
		).dur_(dur).amp_(thisPartialAmp).ris_(ris).dec_(dec).freq_(thisPartialFreq);

		// then and add note for each partial to the score
		score.add(thisPartialNote);
	})
};

// create a score
// the additiveFunc Function will assume a variable named 'score' has been defined.
score = CtkScore.new;


// evaluate the additive synthesis function
// args: start, dur, amp, ris, dec, freq, partialGains
// this function adds individual partials to the score to be played
additiveFunc.value(0.1, 8.0, -15.dbamp, 0.1, 0.1, 220.0, partialGains);


// // play a major scale
// args: start, dur, amp, ris, dec, freq, partialGains
// additiveFunc.value(0.1, 1.0, -15.dbamp, 0.1, 0.1, 57.midicps, partialGains);
// additiveFunc.value(1.1, 1.0, -15.dbamp, 0.1, 0.1, 59.midicps, partialGains);
// additiveFunc.value(2.1, 1.0, -15.dbamp, 0.1, 0.1, 61.midicps, partialGains);
// additiveFunc.value(3.1, 1.0, -15.dbamp, 0.1, 0.1, 62.midicps, partialGains);
// additiveFunc.value(4.1, 1.0, -15.dbamp, 0.1, 0.1, 64.midicps, partialGains);
// additiveFunc.value(5.1, 1.0, -15.dbamp, 0.1, 0.1, 66.midicps, partialGains);
// additiveFunc.value(6.1, 1.0, -15.dbamp, 0.1, 0.1, 68.midicps, partialGains);
// additiveFunc.value(7.1, 1.0, -15.dbamp, 0.1, 0.1, 69.midicps, partialGains);


// play the score
score.play;
)



a = [1, 2, 3, 4];
// b = a.reshape(2,2);
b = a.reshape(2,2);
c = b.lace.reshape(2,2)

// For the next example we're going to put partial gains and ratios together into a single data
// structure to iterate through. We'll use the below sc code to do so

a = [[1, 2, 3, 4], [11, 12, 13, 13]]; // test 2D array
a.shape; // the array shape
b = a.lace; // interlace the values
c = b.reshape(a.shape.at(1), a.shape.at(0)); // regroup values




// Natural sounds often do not have perfectly tuned harmonics.
// Let's add another array, partialRatios where we specify the tuning ratio of each partial.
(
var score, synthDef;
var additiveFunc;
var partialGains = [0, -30, -6, -36, -9, -44, -18, -76, -24, -66, -36]; // gains for clarinet-like timbre
var partialRatios = [1.0, 1.95, 3.05, 4.12, 4.96, 6.15, 7.15, 7.98, 9.1, 10.2, 10.96]; // tuning ratios for each partial
// var partialRatios = [1.2, 1.75, 2.65, 3.62, 4.96, 6.45, 7.05, 7.88, 9.33, 10.27, 11.01]; // tuning ratios for each partial -- non-harmonic!!

synthDef = CtkSynthDef.new(\mySinOscSynth, {arg dur, amp, ris = 0.1, dec = 0.1, freq = 440.0;
	var env, envGen;

	env = Env.linen(ris, 1.0 - (ris + dec), dec); // env define within synthDef
	envGen = EnvGen.kr(env, timeScale: dur);
	amp = envGen * amp;

	Out.ar(0, Pan2.ar(
		// 'amp' is a value between 0 and 1.
		SinOsc.ar(freq, 0, amp)
		)
	)
}).send(s);

// function to add individual notes to our score for additive synthesis
additiveFunc = {arg start, dur, amp, ris = 0.1, dec = 0.1, freq = 440.0, partialGains, partialRatios; // pass in values

	var partialData;

	// group partial gains and ratios into a new array
	// NOTE: we could have required that this information is passed in to the function in this form..
	partialData = [partialGains, partialRatios];
	partialData = partialData.lace; // interlace the values
	partialData = partialData.reshape((partialData.size/2).asInteger, 2); // regroup values

	// iterate through the partialData array to generate individual notes to add to the score
	partialData.do({arg thisPartialData, i;
		var thisPartialAmp;
		var thisPartialFreq;
		var thisPartialNote;

		var thisPartialGain;
		var thisPartialRatio;

		// retreive partial gain and ratio
		thisPartialGain = thisPartialData.at(0);
		thisPartialRatio = thisPartialData.at(1);

		thisPartialAmp = amp * (thisPartialGain.dbamp); // convert thisPartialGain to amp scale and
		// then scale overall amplitude
		thisPartialFreq = freq * thisPartialRatio; // multiply freq by index (harmonic series!)

		// create a note for each partial...
		thisPartialNote = synthDef.note(
			starttime: start, duration: dur
		).dur_(dur).amp_(thisPartialAmp).ris_(ris).dec_(dec).freq_(thisPartialFreq);

		// then and add note for each partial to the score
		score.add(thisPartialNote);
	})
};

// create a score
// the additiveFunc Function will assume a variable named 'score' has been defined.
score = CtkScore.new;


// evaluate the additive synthesis function
// args: start, dur, amp, ris, dec, freq, partialGains, partialRatios
// this function adds individual partials to the score to be played
additiveFunc.value(0.1, 8.0, -15.dbamp, 0.1, 0.1, 220.0, partialGains, partialRatios);


// // play a major scale
// // args: start, dur, amp, ris, dec, freq, partialGains
// additiveFunc.value(0.1, 1.0, -15.dbamp, 0.1, 0.1, 57.midicps, partialGains, partialRatios);
// additiveFunc.value(1.1, 1.0, -15.dbamp, 0.1, 0.1, 59.midicps, partialGains, partialRatios);
// additiveFunc.value(2.1, 1.0, -15.dbamp, 0.1, 0.1, 61.midicps, partialGains, partialRatios);
// additiveFunc.value(3.1, 1.0, -15.dbamp, 0.1, 0.1, 62.midicps, partialGains, partialRatios);
// additiveFunc.value(4.1, 1.0, -15.dbamp, 0.1, 0.1, 64.midicps, partialGains, partialRatios);
// additiveFunc.value(5.1, 1.0, -15.dbamp, 0.1, 0.1, 66.midicps, partialGains, partialRatios);
// additiveFunc.value(6.1, 1.0, -15.dbamp, 0.1, 0.1, 68.midicps, partialGains, partialRatios);
// additiveFunc.value(7.1, 1.0, -15.dbamp, 0.1, 0.1, 69.midicps, partialGains, partialRatios);


// play the score
score.play;
)


/*

Ok, so we can hear that the above sounds somewhat 'out of tune'. The above example is exaggerated, and we can be much more subtle with the tuning ratio choices. The tuning ratios we've listed above are 'harmonic' (more or less related as integer ratios). We can also, of course, choose non-harmonic ratios.

Additionally, while we haven't done so above, it is also possible to add a slight random tuning for each partial. One could use the -rand2 method, for instance, and add this value to the frequency for each partial.

*/

(
// + or - random value
// can be added to the freq value of each partial to give a varying tonal result for each note!
10.0.rand2
)


/*

As you might imagine, we can continue to add individual parameters for each partial. Doing so tends to both enrich the sound and complicate our code! At the moment, all partials have the same duration. In natural sounds, this isn't the case. As a final exercise, let's look at specifying a duration scale for each partial.

Additionally, we'll rearrange things so that we group all the partial data together into a single variable that we pass to the additive synthesis function.


*/



(
var score, synthDef;
var additiveFunc;
var partialGains = [0, -30, -6, -36, -9, -44, -18, -76, -24, -66, -36]; // gains for clarinet-like timbre
var partialRatios = [1.0, 1.95, 3.05, 4.12, 4.96, 6.15, 7.15, 7.98, 9.1, 10.2, 10.96]; // tuning ratios for each partial
var partialDurs = [1, 1, 1, 0.9, 1, 0.8, 0.9, 0.5, 0.7, 0.3, 0.2]; // duration scaling
var partialData;

synthDef = CtkSynthDef.new(\mySinOscSynth, {arg dur, amp, ris = 0.1, dec = 0.1, freq = 440.0;
	var env, envGen;

	env = Env.linen(ris, 1.0 - (ris + dec), dec); // env define within synthDef
	envGen = EnvGen.kr(env, timeScale: dur);
	amp = envGen * amp;

	Out.ar(0, Pan2.ar(
		// 'amp' is a value between 0 and 1.
		SinOsc.ar(freq, 0, amp)
		)
	)
}).send(s);

// function to add individual notes to our score for additive synthesis
additiveFunc = {arg start, dur, amp, ris = 0.1, dec = 0.1, freq = 440.0, partialData; // pass in values

	// var partialData;

	// // group partial gains and ratios into a new array
	// // NOTE: we could have required that this information is passed in to the function in this form..
	// partialData = [partialGains, partialRatios];
	// partialData = partialData.lace; // interlace the values
	// partialData = partialData.reshape((partialData.size/2).asInteger, 2); // regroup values

	// iterate through the partialData array to generate individual notes to add to the score
	partialData.do({arg thisPartialData, i;
		var thisPartialDur;
		var thisPartialAmp;
		var thisPartialFreq;
		var thisPartialNote;

		var thisPartialGain;
		var thisPartialRatio;

		// retreive partial dur, gain and ratio
		thisPartialDur = thisPartialData.at(0);
		thisPartialGain = thisPartialData.at(1);
		thisPartialRatio = thisPartialData.at(2);

		thisPartialDur = dur * thisPartialDur; // scale partial dur by dur argument
		thisPartialAmp = amp * (thisPartialGain.dbamp); // convert thisPartialGain to amp scale and
		// then scale overall amplitude
		thisPartialFreq = freq * thisPartialRatio; // multiply freq by index (harmonic series!)

		// create a note for each partial...
		thisPartialNote = synthDef.note(
			starttime: start, duration: thisPartialDur
		).dur_(thisPartialDur).amp_(thisPartialAmp).ris_(ris).dec_(dec).freq_(thisPartialFreq);

		// then and add note for each partial to the score
		score.add(thisPartialNote);
	})
};

// create a score
// the additiveFunc Function will assume a variable named 'score' has been defined.
score = CtkScore.new;

// group partial durs, gains and ratios into a new array
partialData = [partialDurs, partialGains, partialRatios];
partialData = partialData.lace; // interlace the values
partialData = partialData.reshape((partialData.size/3).asInteger, 3); // regroup values

// partialData.postln;


// evaluate the additive synthesis function
// args: start, dur, amp, ris, dec, freq, partialData
// this function adds individual partials to the score to be played
additiveFunc.value(0.1, 8.0, -15.dbamp, 0.1, 0.1, 220.0, partialData);


// // play a major scale
// // args: start, dur, amp, ris, dec, freq, partialGains
// additiveFunc.value(0.1, 1.0, -15.dbamp, 0.1, 0.1, 57.midicps, partialData);
// additiveFunc.value(1.1, 1.0, -15.dbamp, 0.1, 0.1, 59.midicps, partialData);
// additiveFunc.value(2.1, 1.0, -15.dbamp, 0.1, 0.1, 61.midicps, partialData);
// additiveFunc.value(3.1, 1.0, -15.dbamp, 0.1, 0.1, 62.midicps, partialData);
// additiveFunc.value(4.1, 1.0, -15.dbamp, 0.1, 0.1, 64.midicps, partialData);
// additiveFunc.value(5.1, 1.0, -15.dbamp, 0.1, 0.1, 66.midicps, partialData);
// additiveFunc.value(6.1, 1.0, -15.dbamp, 0.1, 0.1, 68.midicps, partialData);
// additiveFunc.value(7.1, 1.0, -15.dbamp, 0.1, 0.1, 69.midicps, partialData);


// play the score
score.play;
)


// quit:
s.quit;





/*

Stelios Manousakis, University of Washington, 2011
Joseph Anderson, University of Kent, 2012
Joseph Anderson, University of Washington, 2013

*/