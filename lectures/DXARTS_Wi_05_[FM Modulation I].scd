/* DXARTS 461 Digital Sound Synthesis: Class 5 - FM Modulation & Spectral Design */


// FM I - Outline

/*

- Introduction

- Simple FM (sine carrier, sine mododulator)
   - FM parameters
      - fc, fm, d
      - c, m, im, freq
   - FM spectral relation to AM & RM

- trigonometric decomposition to even / odd RM (a la Schottstaedt)

- FM spectral families
   - c:m ratios
   - Normal Form (a la Truax)
   - c:m from f0, f1 (1st two partials)
   - c:m normal form as f1/f0 ratio
   - selecting arbitrary partial number for carrier

- Synthesis Examples

- Modulation of FM index


*/



/*

For our last meeting I (JA) noted, "The class of techniques known as Modulation Synthesis give very flexible and powerful ways to generate spectrally rich tones from simple waveforms." Today we'll have a look at one of the most powerful of these techniques, Freqyency Modulation (FM) Synthesis. FM has been very important in the history of Digital Sound Synthesis in that with only two oscillators it is possible to generate a large number of spectral components! In the early days of digital audio, this was very important, in that computation time was fairly limited (and expensive! if computer time on a main frame computer had to be paid for). Additionally, FM synthesis has a very useful parameter called the "modulation index" which allows us to adjust the number of spectral components generated.

It is worth mentioning that John Chowning's work on FM Synthesis at Stanford's CCRMA resulted in Yamaha's DX-series of synthesisers, the sound of which more or less defines the timbral quality of 1980s synth-pop.

We'll spend much of today looking at the mathematics side of FM. Doing so will give us the opportunity to make some sense of the spectral components which are generated by choosing various carrier and modulator frequencies.

*/


/*

Simple FM (sine carrier, sine mododulator)

Today we'll focus on "Simple FM": a single sine carrier oscillator and a single sine modulator oscillator. This is the synth network illustrated in D&J in figure 5.1.


With Simple FM there are three parameters that can be touched by the musician.

fc : carrier frequency
fm : modulator frequency
d  : modulator deviation


For convenience, these are often expressed in a slightly different way.

c  : carrier frequency ratio
m  : modulator frequency ratio
im : index of modulation

AND

freq : a frequency argument


--
The index of modulation, im, adjusts the number of generated spectral components, or "spectral richness", of the result.

The ratio of c to m (c/m), usually notated as c:m, adjusts the relationship of the spectral components. Simple whole number c:m ratios give harmonic, or "consonant", spectra. Other relationships give inharmonic, or "dissonant", results. We can say that the c:m ratio controls "harmonicity".

The FM algorithm needs fc, fm and d. These are related as:

fc = c * freq
fm = m * freq
d  = im * m * freq

The highest significant energy will be found at:

freq_hi = (c + (1 + im) * m) * freq


In our synthesis, we'll want to make sure that we don't choose an index of modulation (im) that results in freq_hi folding over the Nyquist Frequency!

*/

// PROBLEM: a) write a function to predict highest spectral components given c, m, im, freq




// Let's hear some examples!!


// start server!
Server.default = s = Server.local.boot; // use this for SC-IDE


/*

Start up Stethoscope and FreqScope together:

*/

(
var numChannels = 1;

Stethoscope.new(s, numChannels);
FreqScope.new;
)
// cmd-. to stop
// then, close scope window by hand



// FM synthesis, D&J fig 5.1 (d specified as im)

// FM synthesis in terms of:
//
// freq : a frequency argument
// c    : carrier frequency ratio
// m    : modulator frequency ratio
// im   : index of modulation

(
var score, synthDef;

synthDef = CtkSynthDef.new(\myFMSynth, {arg dur, amp, ris = 0.1, dec = 0.1, freq = 440.0, carRatio = 1, modRatio = 1, modIndex = 1.0;
	var env, envGen;
	var carOsc, modOsc;
	var carFreq, modFreq;
	var modDev;

	// initial calcs
	carFreq = carRatio * freq;
	modFreq = modRatio * freq;
	modDev = modIndex * modFreq;

	env = Env.linen(ris, 1.0 - (ris + dec), dec); // env define within synthDef
	envGen = EnvGen.kr(env, timeScale: dur);

	modOsc = SinOsc.ar(modFreq, 0, modDev);         // simple modulator (single sinusoid)
	carOsc = SinOsc.ar(carFreq + modOsc, 0, amp);   // simple carrier (single sinusoid)

	Out.ar(0, Pan2.ar(
		carOsc * envGen
		)
	)
});


// create a score
score = CtkScore.new;

// add notes to score
score.add(
	// synthDef.note(starttime: 0.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(1).modRatio_(1).modIndex_(1.0), // index!
	// synthDef.note(starttime: 2.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(1).modRatio_(1).modIndex_(2.0),
	// synthDef.note(starttime: 4.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(1).modRatio_(1).modIndex_(4.0)

	// synthDef.note(starttime: 0.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(1).modRatio_(1).modIndex_(1.0), // c:m __m__
	// synthDef.note(starttime: 2.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(1).modRatio_(2).modIndex_(1.0),
	// synthDef.note(starttime: 4.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(1).modRatio_(3).modIndex_(1.0)

	// synthDef.note(starttime: 0.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(1).modRatio_(1).modIndex_(1.0), // c:m __c__
	// synthDef.note(starttime: 2.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(2).modRatio_(1).modIndex_(1.0),
	// synthDef.note(starttime: 4.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(3).modRatio_(1).modIndex_(1.0)

	// synthDef.note(starttime: 0.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(1).modRatio_(2).modIndex_(1.0), // c:m
	// synthDef.note(starttime: 2.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(3).modRatio_(2).modIndex_(1.0),
	// synthDef.note(starttime: 4.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(5).modRatio_(2).modIndex_(1.0)

	// synthDef.note(starttime: 0.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(1).modRatio_(2.4142135623731).modIndex_(1.0), // c:m
	// synthDef.note(starttime: 2.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(1.4142135623731).modRatio_(2.4142135623731).modIndex_(1.0),
	// synthDef.note(starttime: 4.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(3.4142135623731).modRatio_(2.4142135623731).modIndex_(1.0)

	// Truax-Farey series, order 7 (index adjusted...)
	synthDef.note(starttime: 0.1, duration: 1.0).dur_(1.0).amp_(-12.dbamp).freq_(110.0).carRatio_(0).modRatio_(1).modIndex_(10.0),
	synthDef.note(starttime: 1.1, duration: 1.0).dur_(1.0).amp_(-12.dbamp).freq_(110.0).carRatio_(1).modRatio_(7).modIndex_(1.0),
	synthDef.note(starttime: 2.1, duration: 1.0).dur_(1.0).amp_(-12.dbamp).freq_(110.0).carRatio_(1).modRatio_(6).modIndex_(1.5),
	synthDef.note(starttime: 3.1, duration: 1.0).dur_(1.0).amp_(-12.dbamp).freq_(110.0).carRatio_(1).modRatio_(5).modIndex_(2.0),
	synthDef.note(starttime: 4.1, duration: 1.0).dur_(1.0).amp_(-12.dbamp).freq_(110.0).carRatio_(1).modRatio_(4).modIndex_(3.0),
	synthDef.note(starttime: 5.1, duration: 1.0).dur_(1.0).amp_(-12.dbamp).freq_(110.0).carRatio_(2).modRatio_(7).modIndex_(1.0),
	synthDef.note(starttime: 6.1, duration: 1.0).dur_(1.0).amp_(-12.dbamp).freq_(110.0).carRatio_(1).modRatio_(3).modIndex_(2.0),
	synthDef.note(starttime: 7.1, duration: 1.0).dur_(1.0).amp_(-12.dbamp).freq_(110.0).carRatio_(2).modRatio_(5).modIndex_(1.0),
	synthDef.note(starttime: 8.1, duration: 1.0).dur_(1.0).amp_(-12.dbamp).freq_(110.0).carRatio_(3).modRatio_(7).modIndex_(1.0),

	synthDef.note(starttime: 9.1, duration: 1.0).dur_(1.0).amp_(-12.dbamp).freq_(110.0).carRatio_(1).modRatio_(2).modIndex_(5.0),

	synthDef.note(starttime: 10.1, duration: 1.0).dur_(1.0).amp_(-12.dbamp).freq_(110.0).carRatio_(4).modRatio_(7).modIndex_(1.0),
	synthDef.note(starttime: 11.1, duration: 1.0).dur_(1.0).amp_(-12.dbamp).freq_(110.0).carRatio_(3).modRatio_(5).modIndex_(1.5),
	synthDef.note(starttime: 12.1, duration: 1.0).dur_(1.0).amp_(-12.dbamp).freq_(110.0).carRatio_(2).modRatio_(3).modIndex_(3.0),
	synthDef.note(starttime: 13.1, duration: 1.0).dur_(1.0).amp_(-12.dbamp).freq_(110.0).carRatio_(5).modRatio_(7).modIndex_(1.5),
	synthDef.note(starttime: 14.1, duration: 1.0).dur_(1.0).amp_(-12.dbamp).freq_(110.0).carRatio_(3).modRatio_(4).modIndex_(2.5),
	synthDef.note(starttime: 15.1, duration: 1.0).dur_(1.0).amp_(-12.dbamp).freq_(110.0).carRatio_(4).modRatio_(5).modIndex_(2.0),
	synthDef.note(starttime: 16.1, duration: 1.0).dur_(1.0).amp_(-12.dbamp).freq_(110.0).carRatio_(5).modRatio_(6).modIndex_(1.0),
	synthDef.note(starttime: 17.1, duration: 1.0).dur_(1.0).amp_(-12.dbamp).freq_(110.0).carRatio_(6).modRatio_(7).modIndex_(1.0),
	synthDef.note(starttime: 18.1, duration: 1.0).dur_(1.0).amp_(-12.dbamp).freq_(110.0).carRatio_(1).modRatio_(1).modIndex_(10.0),
);

// play the score
score.play;
)



/*

We've seen that the index of modulation, im, gives us control over the number of generated spectral components. Predicting how the c:m ratio relates to the frequency relationships of the spectral components, however, is still somewhat obscure. It turns out there is a very strong relationship to RM and AM!

If we examine the spectral results of RM, AM and FM, (figs 4.16, 4.14, 5.2) we should notice some simularities. I'll illustrate these below.

Let:

fc = carrier frequency
fm = modulator frequency

Carrier and modulator oscillators as sinusoids


Spectral components:

AM : fc, fc - fm, fc + fm
RM : fc - fm, fc + fm
FM : fc ± k*fm, k = 0, 1, 2, 3, ... (number of components is proportional to FM index)


Written out, "in order":

AM :                       fc - 1*fm, fc, fc + 1*fm
RM :                       fc - 1*fm,     fc + 1*fm
FM*: fc - 3*fm, fc - 2*fm, fc - 1*fm, fc, fc + 1*fm, fc + 2*fm, fc + 3*fm

*NOTE: The first k = 0 through 3 FM sidebands

(If a spectral element doesn't appear, a space is left above.)


Above we see that AM, RM and FM are very closely related. One of the big differences is that with simple sines as the carrier and modulator, FM generates a much greater number of spectral components. (The POWER of FM!) Also, we can see that AM and RM are very similar, but for RM the carrier is missing in the result. (RM is a "suppressed carrier" type of modulation.) Let's expand things a bit more to get a greater sense of what is happening.


AM :                       fc - 1*fm, fc ± 0*fm, fc + 1*fm
RM :                       fc - 1*fm,            fc + 1*fm
FM*: fc - 3*fm, fc - 2*fm, fc - 1*fm, fc ± 0*fm, fc + 1*fm, fc + 2*fm, fc + 3*fm


At the centre, I've just replaced fc by fc ± 0*fm. Doing so gives us the ability to see that with FM there appears to be something that looks like a harmonic series appearing, but there is a weirdness of an added value (fc). We can describe this as a harmonic series (related to modulator frequency) reflected about the carrier frequency. (Upper and Lower Sidebands) Going back to the original FM spectral component definition, this becomes clear:

FM : fc ± k*fm, k = 0, 1, 2, 3, ... (number of components is proportional to FM index)

fc     : spectral reflection point
k*fm   : harmonic series (starting with 0Hz)



These relationships become more apparent when we return to AM, but instead of using a single sine oscillator as the modulator, we choose to use an oscillator with more harmonic components. Let's choose to use the 1st three harmonics.

carrier   : single sine [fc]
modulator : complex waveform [1*fm, 2*fm, 3*fm]

AM with these two signals will give us a harmonic series (as defined by fm) reflected about the carrier frequency, fc. The resulting spectral components are shown here, and are the same as the first 3 sidebands generated by FM!:

AM: fc - 3*fm, fc - 2*fm, fc - 1*fm, fc, fc + 1*fm, fc + 2*fm, fc + 3*fm


*****So while we CAN generate the same spectral components with AM, the BIG ADVANTAGE with FM is that the FM index of modulation parameter gives us the independent ability to adjust the number of generated sidebands in real-time ("on the fly"), without having to fill up a wavetable.


*/


// PROBLEM: a) write a function to predict FM spectral components given fc, fm, k
//             b) sort, and remove duplicates
//             c) express this in partial ratios





/*

Simple FM : Trigonometric Decomposition


The close relationship between FM and RM, AM becomes more apparent when we look at FM through the lens of trigonometric identities. The signal processing network for FM can be expressed as:

cos(wc*t + d*sin(wm*t))

OR

sin(wc*t + d*sin(wm*t))


wc, wm : the angular frequencies of fc and fm
t      : the time index


We'll use the 2nd version to work out the math. Note that we can see this as

sin(a + b)

where

a = wc*t
b = d*sin(wm*t)


We can use a trigometric "sum" identity to split sin(a + b) into two parts ("http://en.wikipedia.org/wiki/List_of_trigonometric_identities#Angle_sum_and_difference_identities"):

sin(a + b) = sin(a) * cos(b) + cos(a) * sin(b)


Replacing with our original a, b we get:


sin(wc*t + d*sin(wm*t)) = sin(wc*t) * cos(d*sin(wm*t)) + cos(wc*t) * sin(d*sin(wm*t))


--
sin(wc*t) and cos(wc*t) both represent simple sine oscilitors with a frequency of fc

cos(d*sin(wm*t)) and sin(d*sin(wm*t)) are more difficult to intrepert, but we can note they look a lot like the simple FM equations above, but with a carrier frequency of 0Hz!:


cos(wc*t + d*sin(wm*t)) --> cos(0 + d*sin(wm*t))   // fc = 0
sin(wc*t + d*sin(wm*t)) --> sin(0 + d*sin(wm*t))   // fc = 0


Without going into further detail, we can regard the trigometric "sum" identity as allowing us to view the FM equation as adding together two signals which have been Ring Modulated (RM), or reflected, about fc. It turns out these two signals are the even and odd sideband components!


Intrepeted this way FM is:

sin(wc*t + d*sin(wm*t)) =   sin(wc*t) * cos(d*sin(wm*t))
                            |___A___|   |______C_______|

                          + cos(wc*t) * sin(d*sin(wm*t))
                            |___B___|   |______D_______|


FM = (C RM by A) + (D RM by B)
     |___even__|    |___odd__|


Remember:

FM : fc ± k*fm, k = 0, 1, 2, 3, ... (number of components is proportional to FM index)

The first 1/2 of the split FM equation gives even number of k components, and the second 1/2 gives the odd.


---
Restating this (IMPORTANT) intrepertation of FM spectral components, we can regard the FM equation as generating spectral components which consist of a harmonic series scaled by fm (k*fm, k = 0, 1, 2, 3, ...) which is then reflected about a reflection frequency, fc. This spectral reflection is RM, but the carrier, fc, is NOT surpressed because the even components contain 0Hz!


*/


// Brain hurt yet? Well, the simple answer is that FM and RM (AM) are very closely related....




/*

Simple FM : Spectral Families


Above we've seen how we can calculate the components of an FM spectrum given fc and fm. However, we still have a bit more work to do before we really have control over the spectra generated by the FM technique. Composer Barry Truax has promoted a useful way to classify spectra into groups he describes as "Spectral Families". (The Truax-Farey series example above includes "family members".) We'll explore that here.

Below I've (JA) written a function to calculate frequency components given:

c    : carrier ratio
m    : modulator ratio
freq : frequency
k    : sideband number

*/


// function to predict FM spectral compenents (single carrier/modulator frequency)
// cast as abs(freqs), sort, remove duplicates
(
var removeDuplicatesFunc;
var fmFreqFunc;

// function to remove duplicates
removeDuplicatesFunc = { arg array;
	var result;

	result = Array.newClear;

	array.do({ arg item;
		result.includes(item).not.if({
			result = result.add(item);
		})
	});
	result
};

// function to calculate FM spectrum frequencies
fmFreqFunc = {arg carRatio, modRatio, freq, k;
	var ratios;

	ratios = (k + 1).collect({arg kNum;
		[carRatio - (kNum * modRatio), carRatio + (kNum * modRatio)]
	});

	ratios = ratios.flatten.abs.sort;
	ratios = removeDuplicatesFunc.value(ratios);

	ratios * freq;
};

// // c, m, freq, k ---> same spectral family
// fmFreqFunc.value(1, 1, 440.0, 4).postln; // 1:1
// fmFreqFunc.value(2, 1, 440.0, 4).postln; // 2:1
// fmFreqFunc.value(3, 1, 440.0, 4).postln; // 3:1
// fmFreqFunc.value(4, 1, 440.0, 4).postln; // 4:1

// c, m, freq, k ---> same spectral family
fmFreqFunc.value(1, 5, 110.0, 4).postln; // 1:5
fmFreqFunc.value(4, 5, 110.0, 4).postln; // 4:5
fmFreqFunc.value(6, 5, 110.0, 4).postln; // 6:5
fmFreqFunc.value(11, 5, 110.0, 4).postln; // 11:5

)


/*

(NOTE: some results have 0Hz, DC!)

The interesting thing to note here is that we can get the same spectral components, but with different c:m ratios. These are Truax's Spectral Families. In order to organise these families, Truax introduces a concept he calls the c:m ratio "normal form". Truax is principally concerned with interger c:m ratios, but we can use his thinking to help in more general terms.

The "spectral family normal form" can be descibed as

c:m ratio

c = 1
m = X, where X >= 1

or

c:X, where X >= 1


We can intrepert this as meaning that for an FM spectrum to be in "normal form"

the lowest (fundamental) frequency = fc
the next highest partial frequency = abs(fc - fm)

That is, the 1st lower sideband is reflect across 0Hz, and appears above fc.


Let's express this with some equations to see how it works.

f0 = fundamental frequency
f1 = next highest partial frequency


f0 = fc
f1 = abs(fc - fm)

Assuming spectral normal form:

f0 = fc
f1 = fm - fc

Swapping around to define fc and fm in terms of f0 and f1

fc = f0
fm = f0 + f1


Converting into c:m ratio:

fc:fm

f0:f0 + f1


Dividing out f0 givs us the c:m normal form in terms of f0 and f1:

1:1 + f1/f0

---
Here we notice that we have another ratio, f1/f0. This is the musical interval between the lowest frequency (f0) and the next highest partial (f1). We can create a new parameter, n, to specify that. This parameter can be associated with how harmonically related the resulting FM spectral components will be. Cool!

c:m

1:(1 + n), n >= 1

This gives us the c:m ratio in normal form, where n adjusts the interval between the fundamental (f0) and the next partial (f1). If n is an integer (n >= 1) we'll get spectral components that align with the harmonic series. This doesn't necessarily mean that the result will sound "consonant", but it does mean that we can be guarenteed to align with the harmonic series. If n is not an integer, we're likely to get something that sounds "dissonant" or "metallic". We'll have an inharmonic spectrum.

Summarising, for a spectrum in normal form we can calculate fc and fm in terms of f0 (fundamental) and n (ratio to f1):

fc = f0
fm = (1 + n) * f0, n>= 1


*/


/*

Given n let's write a function to predict the various partial ratios. This will be the synthesised FM spectral series. (Like the harmonic series, but for FM!) We'll assume spectral normal form, so the ratios will be those for the lowest partials.

n    : f1/f0 interval
k    : sideband number


*/


// function to predict FM spectral compenents as ratios (single carrier/modulator frequency)
// cast as + freqs, sort, remove duplicates
(
var removeDuplicatesFunc;
var fmRatiosFunc;

// function to remove duplicates
removeDuplicatesFunc = { arg array;
	var result;

	result = Array.newClear;

	array.do({ arg item;
		result.includes(item).not.if({
			result = result.add(item);
		})
	});
	result
};

// function to calculate FM spectrum ratios
fmRatiosFunc = {arg n, k;
	var ratios;

	ratios = (k + 1).collect({arg kNum;
		[1 - (kNum * (1 + n)), 1 + (kNum * (1 + n))];
	});

	ratios = ratios.flatten.abs.sort;
	ratios = removeDuplicatesFunc.value(ratios);

	ratios;
};

// n, k (n >= 1) ---> harmonic series...
fmRatiosFunc.value(1, 4).postln; // 1:(1 + 1) = 1:2 ---> 2nd partial, unison
fmRatiosFunc.value(2, 4).postln; // 1:(1 + 2) = 1:3 ---> 2nd partial, octave
fmRatiosFunc.value(3, 4).postln; // 1:(1 + 3) = 1:4 ---> 2nd partial, octave + 5th
fmRatiosFunc.value(4, 4).postln; // 1:(1 + 4) = 1:5 ---> 2nd partial, 2 octaves

// // n, k (n >= 1) ---> just intonation...
// fmRatiosFunc.value(1/1, 4).postln; // 1:(1 + 1/1) = 1:2     ---> 2nd partial, unison
// fmRatiosFunc.value(9/8, 4).postln; // 1:(1 + 9/8) = 1:1.25  ---> 2nd partial, major 2nd
// fmRatiosFunc.value(5/4, 4).postln; // 1:(1 + 5/4) = 1:1.5   ---> 2nd partial, major 3rd
// fmRatiosFunc.value(4/3, 4).postln; // 1:(1 + 4/3) = 1:1.667 ---> 2nd partial, perfect 4th

)


/*

Ok, that's cool! We've managed to define FM spectra where we have the freedom to control the musical ratio between the lowest partial, "fundamental", and then next highest partial. Let's audition the result.


*/


// FM synthesis in terms of:
//
// freq : fundamental frequency
// n    : f1/f0 interval
// im   : modulation index

(
var score, synthDef;
var cmRatioFunc;

synthDef = CtkSynthDef.new(\myFMSynth, {arg dur, amp, ris = 0.1, dec = 0.1, freq = 440.0, carRatio = 1, modRatio = 1, modIndex = 1.0;
	var env, envGen;
	var carOsc, modOsc;
	var carFreq, modFreq;
	var modDev;

	// initial calcs
	carFreq = carRatio * freq;
	modFreq = modRatio * freq;
	modDev = modIndex * modFreq;

	env = Env.linen(ris, 1.0 - (ris + dec), dec); // env define within synthDef
	envGen = EnvGen.kr(env, timeScale: dur);

	modOsc = SinOsc.ar(modFreq, 0, modDev);         // simple modulator (single sinusoid)
	carOsc = SinOsc.ar(carFreq + modOsc, 0, amp);   // simple carrier (single sinusoid)

	Out.ar(0, Pan2.ar(
		carOsc * envGen
		)
	)
});


// function to calculate c:m from n, ratio between f0 and f1
// FM spectrum in normal form
cmRatioFunc = {arg n;
	[1, (1 + n)]
};


// create a score
score = CtkScore.new;

// add notes to score
score.add(

	// // n, (n >= 1) ---> harmonic series...
	// // 1:(1 + n)
	// // 1:(1 + 1) = 1:2 ---> 2nd partial, unison
	// // 1:(1 + 2) = 1:3 ---> 2nd partial, octave
	// // 1:(1 + 3) = 1:4 ---> 2nd partial, octave + 5th
	// // 1:(1 + 4) = 1:5 ---> 2nd partial, 2 octaves
	// synthDef.note(starttime: 0.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(1).at(0)).modRatio_(cmRatioFunc.value(1).at(1)).modIndex_(1.0),
	// synthDef.note(starttime: 2.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(2).at(0)).modRatio_(cmRatioFunc.value(2).at(1)).modIndex_(1.0),
	// synthDef.note(starttime: 4.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(3).at(0)).modRatio_(cmRatioFunc.value(3).at(1)).modIndex_(0.75),
	// synthDef.note(starttime: 6.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(4).at(0)).modRatio_(cmRatioFunc.value(4).at(1)).modIndex_(0.5),

	// n, (n >= 1) ---> just intonation...
	// 1:(1 +  1/1) = 1:2     ---> 2nd partial, unison
	// 1:(1 +  9/8) = 1:1.25  ---> 2nd partial, major 2nd
	// 1:(1 +  5/4) = 1:1.5   ---> 2nd partial, major 3rd
	// 1:(1 +  4/3) = 1:1.667 ---> 2nd partial, perfect 4th
	// 1:(1 +  3/2) = 1:2.5   ---> 2nd partial, perfect 5th
	// 1:(1 +  5/3) = 1:2.667 ---> 2nd partial, major 6th
	// 1:(1 + 15/8) = 1:2.875 ---> 2nd partial, major 7th
	// 1:(1 +  2/1) = 1:3     ---> 2nd partial, octave
	synthDef.note(starttime: 0.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(1).at(0)).modRatio_(cmRatioFunc.value(1).at(1)).modIndex_(1.0),
	synthDef.note(starttime: 2.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(9/8).at(0)).modRatio_(cmRatioFunc.value(9/8).at(1)).modIndex_(1.0),
	synthDef.note(starttime: 4.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(5/4).at(0)).modRatio_(cmRatioFunc.value(5/4).at(1)).modIndex_(1.0),
	synthDef.note(starttime: 6.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(4/3).at(0)).modRatio_(cmRatioFunc.value(4/3).at(1)).modIndex_(1.0),
	synthDef.note(starttime: 8.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(3/2).at(0)).modRatio_(cmRatioFunc.value(3/2).at(1)).modIndex_(1.0),
	synthDef.note(starttime: 10.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(5/3).at(0)).modRatio_(cmRatioFunc.value(5/3).at(1)).modIndex_(1.0),
	synthDef.note(starttime: 12.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(15/8).at(0)).modRatio_(cmRatioFunc.value(15/8).at(1)).modIndex_(1.0),
	synthDef.note(starttime: 14.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(2).at(0)).modRatio_(cmRatioFunc.value(2).at(1)).modIndex_(1.0),
);

// play the score
score.play;
)







/*

FM Spectrum Family: Family Members

There's one more thing we need to get a handle on. Now that we have defined an FM spectral family in normal form, we'd like to be able to easily generate the other members of the family. To gain some insight into this, we'll begin by listing out FM spectrum components (normal form, up to k = 4):


f0 = abs(fc ± 0 * fm)
f1 = abs(fc - 1 * fm)
f2 = abs(fc + 1 * fm)
f3 = abs(fc - 2 * fm)
f4 = abs(fc + 2 * fm)
f5 = abs(fc - 3 * fm)
f6 = abs(fc + 3 * fm)
f7 = abs(fc - 4 * fm)
f8 = abs(fc + 4 * fm)


We've listed every component frequency as abs(), as this is how the ear will hear. Evaluating the abs() gives us this form:


f0 = 0 * fm ± fc
f1 = 1 * fm - fc
f2 = 1 * fm + fc
f3 = 2 * fm - fc
f4 = 2 * fm + fc
f5 = 3 * fm - fc
f6 = 3 * fm + fc
f7 = 4 * fm - fc
f8 = 4 * fm + fc


Here we can observe that even and odd spectral components can be found:

p = 0, 1, 2, 3...
where p is the partial number


f_p_even =       p/2 * fm + fc
f_p_odd  = (p + 1)/2 * fm - fc


What this does is allow us to find the frequency value partial number p (any partial!) from any carrier (fm) and modulator (fc) combination. Above we've defined the ratio between f1 and f0 as n, allowing us to specify a spectrum in this more general way. Let's work out how to do this for the above two equations.


c:m
1:1 + f1/f0   // c:m ratio expressed in terms of f1 and f0
1:1 + n       // c:m ratio exptressed in terms of n, n >= 1


We can just substitute directly and get:


f_p_even =       p/2 * (1 + n) + 1
f_p_odd  = (p + 1)/2 * (1 + n) - 1



-----
Individual FM spectrum family members are generated by placing the carrier at other spectral components (partial numbers) once the normal form of a spectral family has been defined. You can think of it as choosing which partial will be the carrier. Or, another way to think of it is that the various family members are somewhat similar to "chordal inversions" in Western Common Practice Tonal Harmony.

Let's finish and derive the c:m ratios that will give us any family member. Here, we'll just substitute the above relations for f_p_even and f_p_odd into the c:m relationship we've already defined.


n is the ratio between f1 and f0
p is the partial number


n >= 1
p =  0, 1, 2, 3...

                      c:m
      p/2 * (1 + n) + 1:(1 + n)   ; for p_even
(p + 1)/2 * (1 + n) - 1:(1 + n)   ; for p_odd



This is our final c:m relationship!!

n defines the spectral family (in terms of musical ratio f1/f0)
p defines the family member (in terms of carrier @ partial number)


Integer values of n give subsets of the harmonic series. (But we're not required to do so.) As we vary n we'll get spectral families with varying sense of consonance and disonance. Once a spectral family is chosen (by defining n), p allows us to move to carrier to various partials. p = 0 gives the carrier at the fundamental, which is the normal form of the spectrum. Other integer values give move the carrier to that partial number. E.g., p = 4 gives us the 5th partial (as we're counting partials from 0).


*/




/*

Let's implement this in a function!!

Given:

n    : f1/f0 interval
p    : fc partial number
k    : sideband number


Calculate:

c    : carrier ratio
m    : modulator ratio

AND

fm spectrum ratios



*/


// function to predict c:m
// function to predict FM spectral compenents (single carrier/modulator frequency)
// cast as + freqs, sort, remove duplicates
(
var removeDuplicatesFunc;
var fmRatiosFunc;
var cmRatioFunc;

// function to remove duplicates
removeDuplicatesFunc = { arg array;
	var result;

	result = Array.newClear;

	array.do({ arg item;
		result.includes(item).not.if({
			result = result.add(item);
		})
	});
	result
};


// function to calculate c:m
cmRatioFunc = {arg n, p;
	var cm;

	p.even.if({
		cm = [                        // p is even case
			(p)/2 * (1 + n) + 1,      // carrier
			(1 + n)                   // modulator
		]
	},{
		cm = [                        // p is odd case
			(p + 1)/2 * (1 + n) - 1,  // carrier
			(1 + n)                   // modulator
			]
	});
	cm
};


// function to calculate FM spectrum ratios
fmRatiosFunc = {arg cm, k;
	var ratios;

	ratios = (k + 1).collect({arg kNum;
		[cm.at(0) - (kNum * cm.at(1)), cm.at(0) + (kNum * cm.at(1))];
	});

	ratios = ratios.flatten.abs.sort;
	ratios = removeDuplicatesFunc.value(ratios);

	ratios;
};




// // calculate c:m -- p1/p0 octave relationship
// // n    : f1/f0 interval
// // p    : fc partial number
// cmRatioFunc.value(2, 0).postln;
// cmRatioFunc.value(2, 1).postln;
// cmRatioFunc.value(2, 2).postln;
// cmRatioFunc.value(2, 3).postln;


// // calculate fm spectrum ratios -- p1/p0 octave relationship
// // n    : f1/f0 interval
// // p    : fc partial number
// // k    : sideband number
// cmRatioFunc.value(2, 0).postln;
// fmRatiosFunc.value(cmRatioFunc.value(2, 0), 4).postln;
// cmRatioFunc.value(2, 1).postln;
// fmRatiosFunc.value(cmRatioFunc.value(2, 1), 4).postln;
// cmRatioFunc.value(2, 2).postln;
// fmRatiosFunc.value(cmRatioFunc.value(2, 2), 4).postln;
// cmRatioFunc.value(2, 3).postln;
// fmRatiosFunc.value(cmRatioFunc.value(2, 3), 4).postln;



// // calculate c:m -- p1/p0 perfect 5th relationship
// // n    : f1/f0 interval
// // p    : fc partial number
// cmRatioFunc.value(3/2, 0).postln;
// cmRatioFunc.value(3/2, 1).postln;
// cmRatioFunc.value(3/2, 2).postln;
// cmRatioFunc.value(3/2, 3).postln;


// calculate fm spectrum ratios -- p1/p0 perfect 5th relationship
// n    : f1/f0 interval
// p    : fc partial number
// k    : sideband number
cmRatioFunc.value(3/2, 0).postln;
fmRatiosFunc.value(cmRatioFunc.value(3/2, 0), 4).postln;
cmRatioFunc.value(3/2, 1).postln;
fmRatiosFunc.value(cmRatioFunc.value(3/2, 1), 4).postln;
cmRatioFunc.value(3/2, 2).postln;
fmRatiosFunc.value(cmRatioFunc.value(3/2, 2), 4).postln;
cmRatioFunc.value(3/2, 3).postln;
fmRatiosFunc.value(cmRatioFunc.value(3/2, 3), 4).postln;



// // calculate c:m -- p1/p0 tritone relationship
// // n    : f1/f0 interval
// // p    : fc partial number
// cmRatioFunc.value(2.sqrt, 0).postln;
// cmRatioFunc.value(2.sqrt, 1).postln;
// cmRatioFunc.value(2.sqrt, 2).postln;
// cmRatioFunc.value(2.sqrt, 3).postln;


// // calculate fm spectrum ratios -- p1/p0 tritone relationship
// // n    : f1/f0 interval
// // p    : fc partial number
// // k    : sideband number
// cmRatioFunc.value(2.sqrt, 0).postln;
// fmRatiosFunc.value(cmRatioFunc.value(2.sqrt, 0), 4).postln;
// cmRatioFunc.value(2.sqrt, 1).postln;
// fmRatiosFunc.value(cmRatioFunc.value(2.sqrt, 1), 4).postln;
// cmRatioFunc.value(2.sqrt, 2).postln;
// fmRatiosFunc.value(cmRatioFunc.value(2.sqrt, 2), 4).postln;
// cmRatioFunc.value(2.sqrt, 3).postln;
// fmRatiosFunc.value(cmRatioFunc.value(2.sqrt, 3), 4).postln;


)



/*

Let's now audition a few of the different "family members" of a single spectral family. What we are doing is defining a normal spectrum, and then choosing different partials (partial number) to place the carrier.


*/


// FM synthesis in terms of:
//
// freq : fundamental frequency
// n    : f1/f0 interval
// p    : fc partial number
// im   : modulation index


(
var score, synthDef;
var cmRatioFunc;

synthDef = CtkSynthDef.new(\myFMSynth, {arg dur, amp, ris = 0.1, dec = 0.1, freq = 440.0, carRatio = 1, modRatio = 1, modIndex = 1.0;
	var env, envGen;
	var carOsc, modOsc;
	var carFreq, modFreq;
	var modDev;

	// initial calcs
	carFreq = carRatio * freq;
	modFreq = modRatio * freq;
	modDev = modIndex * modFreq;

	env = Env.linen(ris, 1.0 - (ris + dec), dec); // env define within synthDef
	envGen = EnvGen.kr(env, timeScale: dur);

	modOsc = SinOsc.ar(modFreq, 0, modDev);         // simple modulator (single sinusoid)
	carOsc = SinOsc.ar(carFreq + modOsc, 0, amp);   // simple carrier (single sinusoid)

	Out.ar(0, Pan2.ar(
		carOsc * envGen
		)
	)
});


// function to calculate c:m
// n, n >=1 ratio between f0 and f1
// p, p = 0, 1, 2, 3, ... partial number
cmRatioFunc = {arg n, p;
	var cm;

	p.even.if({
		cm = [                        // p is even case
			(p)/2 * (1 + n) + 1,      // carrier
			(1 + n)                   // modulator
		]
	},{
		cm = [                        // p is odd case
			(p + 1)/2 * (1 + n) - 1,  // carrier
			(1 + n)                   // modulator
			]
	});
	cm
};


// create a score
score = CtkScore.new;

// add notes to score
score.add(

	// // calculate c:m -- p1/p0 octave relationship
	// // n    : f1/f0 interval
	// // p    : fc partial number
	// cmRatioFunc.value(2, 0).postln;
	// cmRatioFunc.value(2, 1).postln;
	// cmRatioFunc.value(2, 2).postln;
	// cmRatioFunc.value(2, 3).postln;
	synthDef.note(starttime: 0.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(2, 0).at(0)).modRatio_(cmRatioFunc.value(2, 0).at(1)).modIndex_(1.0),
	synthDef.note(starttime: 2.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(2, 1).at(0)).modRatio_(cmRatioFunc.value(2, 1).at(1)).modIndex_(1.0),
	synthDef.note(starttime: 4.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(2, 2).at(0)).modRatio_(cmRatioFunc.value(2, 2).at(1)).modIndex_(0.75),
	synthDef.note(starttime: 6.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(2, 3).at(0)).modRatio_(cmRatioFunc.value(2, 3).at(1)).modIndex_(0.5),


	// // // calculate c:m -- p1/p0 perfect 5th relationship
	// // // n    : f1/f0 interval
	// // // p    : fc partial number
	// // cmRatioFunc.value(3/2, 0).postln;
	// // cmRatioFunc.value(3/2, 1).postln;
	// // cmRatioFunc.value(3/2, 2).postln;
	// // cmRatioFunc.value(3/2, 3).postln;
	// synthDef.note(starttime: 0.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(3/2, 0).at(0)).modRatio_(cmRatioFunc.value(3/2, 0).at(1)).modIndex_(1.0),
	// synthDef.note(starttime: 2.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(3/2, 1).at(0)).modRatio_(cmRatioFunc.value(3/2, 1).at(1)).modIndex_(1.0),
	// synthDef.note(starttime: 4.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(3/2, 2).at(0)).modRatio_(cmRatioFunc.value(3/2, 2).at(1)).modIndex_(0.75),
	// synthDef.note(starttime: 6.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(3/2, 3).at(0)).modRatio_(cmRatioFunc.value(3/2, 3).at(1)).modIndex_(0.5),


	// // // calculate c:m -- p1/p0 tritone relationship
	// // // n    : f1/f0 interval
	// // // p    : fc partial number
	// // cmRatioFunc.value(2.sqrt, 0).postln;
	// // cmRatioFunc.value(2.sqrt, 1).postln;
	// // cmRatioFunc.value(2.sqrt, 2).postln;
	// // cmRatioFunc.value(2.sqrt, 3).postln;
	// synthDef.note(starttime: 0.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(2.sqrt, 0).at(0)).modRatio_(cmRatioFunc.value(2.sqrt, 0).at(1)).modIndex_(1.0),
	// synthDef.note(starttime: 2.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(2.sqrt, 1).at(0)).modRatio_(cmRatioFunc.value(2.sqrt, 1).at(1)).modIndex_(1.0),
	// synthDef.note(starttime: 4.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(2.sqrt, 2).at(0)).modRatio_(cmRatioFunc.value(2.sqrt, 2).at(1)).modIndex_(0.75),
	// synthDef.note(starttime: 6.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(440.0).carRatio_(cmRatioFunc.value(2.sqrt, 3).at(0)).modRatio_(cmRatioFunc.value(2.sqrt, 3).at(1)).modIndex_(0.5),

);

// play the score
score.play;
)





/*

Simple FM : Modulating the FM modulation index


To this point we've been focusing on the spectral components that FM allows us to easily generate. As you've seen, by using the n and p parameters, we have a great deal of control here. While we have been touching im, the modulation index, to control the number of spectral components generated, we've left this a a constant for the duration of the note event. The last thing we'll do today is add an envelope to scale the modulation index in real-time. As you'll hear, the results are quite distinctive... and attractive!!!


Here we'll do something simple, and just map the modulation index to a linear envelope ascending from 0 to im (score the value we'll specify) for the first half of the note, and return to 0 for the 2nd half. This should illustrate clearly what happens with spectral evolution when the modulation index is changed.

As you'd imagine, we're not limited to mapping to such a simple envelope. We could choose an exponential (good for synthesising bell or mallet sound!) or another function. Additionally, we could also choose to slowly modulate the modulation index with a sub-audio rate oscillator. (Remember, values should be between 0 and max index.)

*/



// FM synthesis in terms of:
//
// freq : fundamental frequency
// n    : f1/f0 interval
// p    : fc partial number
// im   : modulation index

// various spectral family members, but with modulating index
(
var score, synthDef;
var cmRatioFunc;

synthDef = CtkSynthDef.new(\myFMSynth, {arg dur, amp, ris = 0.1, dec = 0.1, freq = 440.0, carRatio = 1, modRatio = 1, modIndex = 1.0;
	var envGen;
	var carOsc, modOsc;
	var carFreq, modFreq;
	var modDev;
	var modEnvGen;

	// initial calcs
	carFreq = carRatio * freq;
	modFreq = modRatio * freq;
	modDev = modIndex * modFreq;

	envGen = EnvGen.kr(
		Env.linen(ris, 1.0 - (ris + dec), dec),     // env definition moved within EnvGen
		timeScale: dur
	);

	modEnvGen = EnvGen.kr(
		Env.triangle(1.0),                          // env definition moved within EnvGen
		timeScale: dur
	);

	modOsc = SinOsc.ar(modFreq, 0, modDev * modEnvGen);  // simple modulator (single sinusoid)
	carOsc = SinOsc.ar(carFreq + modOsc, 0, amp);        // simple carrier (single sinusoid)

	Out.ar(0, Pan2.ar(
		carOsc * envGen
		)
	)
});


// function to calculate c:m
// n, n >=1 ratio between f0 and f1
// p, p = 0, 1, 2, 3, ... partial number
cmRatioFunc = {arg n, p;
	var cm;

	p.even.if({
		cm = [                        // p is even case
			(p)/2 * (1 + n) + 1,      // carrier
			(1 + n)                   // modulator
		]
	},{
		cm = [                        // p is odd case
			(p + 1)/2 * (1 + n) - 1,  // carrier
			(1 + n)                   // modulator
			]
	});
	cm
};


// create a score
score = CtkScore.new;

// add notes to score
score.add(

	// // calculate c:m -- p1/p0 octave relationship
	// // n    : f1/f0 interval
	// // p    : fc partial number
	// cmRatioFunc.value(2, 0).postln;
	// cmRatioFunc.value(2, 1).postln;
	// cmRatioFunc.value(2, 2).postln;
	// cmRatioFunc.value(2, 3).postln;
	// cmRatioFunc.value(2, 4).postln;
	// cmRatioFunc.value(2, 5).postln;
	synthDef.note(starttime: 0.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(2, 0).at(0)).modRatio_(cmRatioFunc.value(2, 0).at(1)).modIndex_(1.0),
	synthDef.note(starttime: 2.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(2, 1).at(0)).modRatio_(cmRatioFunc.value(2, 1).at(1)).modIndex_(1.0),
	synthDef.note(starttime: 4.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(2, 2).at(0)).modRatio_(cmRatioFunc.value(2, 2).at(1)).modIndex_(1.0),
	synthDef.note(starttime: 6.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(2, 3).at(0)).modRatio_(cmRatioFunc.value(2, 3).at(1)).modIndex_(1.0),
	synthDef.note(starttime: 8.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(2, 4).at(0)).modRatio_(cmRatioFunc.value(2, 4).at(1)).modIndex_(1.0),
	synthDef.note(starttime: 10.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(2, 5).at(0)).modRatio_(cmRatioFunc.value(2, 5).at(1)).modIndex_(1.0),


	// // // calculate c:m -- p1/p0 perfect 5th relationship
	// // // n    : f1/f0 interval
	// // // p    : fc partial number
	// // cmRatioFunc.value(3/2, 0).postln;
	// // cmRatioFunc.value(3/2, 1).postln;
	// // cmRatioFunc.value(3/2, 2).postln;
	// // cmRatioFunc.value(3/2, 3).postln;
	// // cmRatioFunc.value(3/2, 4).postln;
	// // cmRatioFunc.value(3/2, 5).postln;
	// synthDef.note(starttime: 0.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(3/2, 0).at(0)).modRatio_(cmRatioFunc.value(3/2, 0).at(1)).modIndex_(1.5),
	// synthDef.note(starttime: 2.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(3/2, 1).at(0)).modRatio_(cmRatioFunc.value(3/2, 1).at(1)).modIndex_(1.25),
	// synthDef.note(starttime: 4.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(3/2, 2).at(0)).modRatio_(cmRatioFunc.value(3/2, 2).at(1)).modIndex_(1.0),
	// synthDef.note(starttime: 6.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(3/2, 3).at(0)).modRatio_(cmRatioFunc.value(3/2, 3).at(1)).modIndex_(1.0),
	// synthDef.note(starttime: 8.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(3/2, 4).at(0)).modRatio_(cmRatioFunc.value(3/2, 4).at(1)).modIndex_(1.5),
	// synthDef.note(starttime: 10.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(3/2, 5).at(0)).modRatio_(cmRatioFunc.value(3/2, 5).at(1)).modIndex_(2.0),


	// // // calculate c:m -- p1/p0 major 6th relationship
	// // // n    : f1/f0 interval
	// // // p    : fc partial number
	// // cmRatioFunc.value(5/3, 0).postln;
	// // cmRatioFunc.value(5/3, 1).postln;
	// // cmRatioFunc.value(5/3, 2).postln;
	// // cmRatioFunc.value(5/3, 3).postln;
	// // cmRatioFunc.value(5/3, 4).postln;
	// // cmRatioFunc.value(5/3, 5).postln;
	// synthDef.note(starttime: 0.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(5/3, 0).at(0)).modRatio_(cmRatioFunc.value(5/3, 0).at(1)).modIndex_(1.5),
	// synthDef.note(starttime: 2.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(5/3, 1).at(0)).modRatio_(cmRatioFunc.value(5/3, 1).at(1)).modIndex_(1.25),
	// synthDef.note(starttime: 4.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(5/3, 2).at(0)).modRatio_(cmRatioFunc.value(5/3, 2).at(1)).modIndex_(1.0),
	// synthDef.note(starttime: 6.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(5/3, 3).at(0)).modRatio_(cmRatioFunc.value(5/3, 3).at(1)).modIndex_(1.0),
	// synthDef.note(starttime: 8.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(5/3, 4).at(0)).modRatio_(cmRatioFunc.value(5/3, 4).at(1)).modIndex_(1.5),
	// synthDef.note(starttime: 10.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(5/3, 5).at(0)).modRatio_(cmRatioFunc.value(5/3, 5).at(1)).modIndex_(2.0),


	// // // calculate c:m -- p1/p0 tritone relationship
	// // // n    : f1/f0 interval
	// // // p    : fc partial number
	// // cmRatioFunc.value(2.sqrt, 0).postln;
	// // cmRatioFunc.value(2.sqrt, 1).postln;
	// // cmRatioFunc.value(2.sqrt, 2).postln;
	// // cmRatioFunc.value(2.sqrt, 3).postln;
	// // cmRatioFunc.value(2.sqrt, 4).postln;
	// // cmRatioFunc.value(2.sqrt, 5).postln;
	// synthDef.note(starttime: 0.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(2.sqrt, 0).at(0)).modRatio_(cmRatioFunc.value(2.sqrt, 0).at(1)).modIndex_(1.5),
	// synthDef.note(starttime: 2.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(2.sqrt, 1).at(0)).modRatio_(cmRatioFunc.value(2.sqrt, 1).at(1)).modIndex_(1.25),
	// synthDef.note(starttime: 4.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(2.sqrt, 2).at(0)).modRatio_(cmRatioFunc.value(2.sqrt, 2).at(1)).modIndex_(1.0),
	// synthDef.note(starttime: 6.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(2.sqrt, 3).at(0)).modRatio_(cmRatioFunc.value(2.sqrt, 3).at(1)).modIndex_(1.0),
	// synthDef.note(starttime: 8.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(2.sqrt, 4).at(0)).modRatio_(cmRatioFunc.value(2.sqrt, 4).at(1)).modIndex_(1.5),
	// synthDef.note(starttime: 10.1, duration: 2.0).dur_(2.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(2.sqrt, 5).at(0)).modRatio_(cmRatioFunc.value(2.sqrt, 5).at(1)).modIndex_(2.0),



	// // An example of overlapping notes (all in the same family)...
	//
	// // // calculate c:m -- p1/p0 major 6th relationship
	// // // n    : f1/f0 interval
	// // // p    : fc partial number
	// // cmRatioFunc.value(5/3, 0).postln;
	// // cmRatioFunc.value(5/3, 1).postln;
	// // cmRatioFunc.value(5/3, 2).postln;
	// // cmRatioFunc.value(5/3, 3).postln;
	// // cmRatioFunc.value(5/3, 4).postln;
	// // cmRatioFunc.value(5/3, 5).postln;
	// synthDef.note(starttime: 0.1, duration: 5.0).dur_(5.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(5/3, 0).at(0)).modRatio_(cmRatioFunc.value(5/3, 0).at(1)).modIndex_(1.5).ris_(0.5).dec_(0.5),
	// synthDef.note(starttime: 2.1, duration: 5.0).dur_(5.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(5/3, 1).at(0)).modRatio_(cmRatioFunc.value(5/3, 1).at(1)).modIndex_(1.25).ris_(0.5).dec_(0.5),
	// synthDef.note(starttime: 4.1, duration: 5.0).dur_(5.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(5/3, 2).at(0)).modRatio_(cmRatioFunc.value(5/3, 2).at(1)).modIndex_(1.0).ris_(0.5).dec_(0.5),
	// synthDef.note(starttime: 6.1, duration: 5.0).dur_(5.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(5/3, 3).at(0)).modRatio_(cmRatioFunc.value(5/3, 3).at(1)).modIndex_(1.0).ris_(0.5).dec_(0.5),
	// synthDef.note(starttime: 8.1, duration: 5.0).dur_(5.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(5/3, 4).at(0)).modRatio_(cmRatioFunc.value(5/3, 4).at(1)).modIndex_(1.5).ris_(0.5).dec_(0.5),
	// synthDef.note(starttime: 10.1, duration: 5.0).dur_(5.0).amp_(-12.dbamp).freq_(220.0).carRatio_(cmRatioFunc.value(5/3, 5).at(0)).modRatio_(cmRatioFunc.value(5/3, 5).at(1)).modIndex_(2.0).ris_(0.5).dec_(0.5),



);

// play the score
score.play;
)


/*

With this very last example, the addition of the various members of a single FM family can be thought of as a kind of Additive Synthesis, but with FM spectra as the additive source. The FM techinque is quite powerful--allowing us to generate a variety of dynamic spectra. And, as you can imagine, with a bit of planning the technique can be used to create very compelling textures and structures.

*/



// quit:
s.quit;





/*

Joseph Anderson, University of Washington, 2013

*/